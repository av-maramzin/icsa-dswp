<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Icsa-dswp by smanilov</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/smanilov/icsa-dswp">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/smanilov/icsa-dswp/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/smanilov/icsa-dswp/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Icsa-dswp</h1>
          <p>An implementation of Decoupled Software Pipelining</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/smanilov">smanilov</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

        <h1>
<a id="an-implementation-of-dswp" class="anchor" href="#an-implementation-of-dswp" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>An implementation of DSWP</h1>

<p>Currently, under development.</p>

<h2>
<a id="goals" class="anchor" href="#goals" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Goals</h2>

<p>Decoupled Software Pipelining (DSWP) is an automatic thread extraction technique
(Ottoni, 2005). There have been previous attempts at implementing
it (2011 project and 2013 project), but the
efforts resulted in unfinished and unmaintainable solutions.</p>

<p>Therefore, the goals of this project are to provide a complete, reusable and
maintainable implementation of the technique, which can then be integrated in
prototypes of further research on the topic.</p>

<h2>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Usage</h2>

<h3>
<a id="prerequisites" class="anchor" href="#prerequisites" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Prerequisites</h3>

<p>This project depends on LLVM+Clang 3.7.0 and is developed on Linux. Thus, no
guarantees are made that it's going to work with any other version of LLVM or on
any other operating system - sorry. Make sure you have the LLVM+Clang 3.7.0
binary directory on your system PATH in order to build and use the pass.</p>

<h3>
<a id="building" class="anchor" href="#building" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Building</h3>

<p>Run <code>tools/build.sh</code>. This script will use <code>cmake 2.8</code> and <code>make</code> in order to
build the project.</p>

<h2>
<a id="development" class="anchor" href="#development" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Development</h2>

<h3>
<a id="disclaimer" class="anchor" href="#disclaimer" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Disclaimer</h3>

<p>The following text would describe the repository when the implementation is
completed - it may not describe its working state.</p>

<h3>
<a id="available-passes" class="anchor" href="#available-passes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Available Passes</h3>

<p>The <code>pass</code> directory contains the code for <code>libdswp.so</code> - a library that
contains the following LLVM 3.7.0 function passes:</p>

<ul>
<li>
<code>ddg</code> - builds the Data Dependence Graph of a function using the Use-Def
chains already built-in LLVM; in order for this pass to work, the bytecode
should be in SSA form;

<ul>
<li>
<code>mdg</code> - builds the Memory Dependence Graph of a function using
<code>llvm / Analysis / MemoryDependenceAnalysis.h</code>;
only instruction definition dependencies are considered(no clobber /
                                                alias dependencies);</li>
<li>
<code>cdg</code> - builds theControl Dependence Graph of a function;</li>
<li>
<code>pdg</code> - combines the previous three graphs in a single graph of instruction
      dependencies;
note that since <code>cdg</code> produces a basic block dependence graph all of the
instructions in the dependant block are made to depend on the branch
instruction of the dependency source;</li>
<li>
<code>psg</code> - incomplete and memory leaking experimental pass;
finds the Strongly Connected Components of the Program Dependence
Graph and builds a graph out of them;</li>
</ul>
</li>
<li>
<code>dot-XXX</code> - prints a .dot representation of each function for the graph build
by <code>XXX</code> to a file;
<code>XXX</code> is one of the five graph building passes;</li>
<li>
<code>find-dswp</code> - uses the experimental <code>psg</code> pass to analyse an LLVM bytecode
file and prints DSWP opportunities to the standard output.</li>
</ul>

<p>In order to analyze a <code>.cpp</code> file called <code>foo.cpp</code>, make sure you have LLVM
3.7.0 installed and do the following:</p>

<pre><code>clang++ foo.cpp -c -emit-llvm -o foo.bc
opt -mem2dep foo.bc -o ssa.bc
opt -load $ICSA_DSWP_HOME/build/pass/libdswp.so -find-dswp ssa.bc -o /dev/null
</code></pre>

<p>The <code>test</code> directory contains example programs on which the DSWP pass can be
tested and demonstrated.</p>

<h3>
<a id="code-structure" class="anchor" href="#code-structure" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Code Structure</h3>

<p>This section talks about the source code of the project. It is meant to be read
while looking at the source code, so go ahead and open an editor.</p>

<h4>
<a id="dependenceh" class="anchor" href="#dependenceh" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Dependence.h</h4>

<p>The starting point for understanding the code is the <code>Dependence.h</code> header file.
It implements the template class <code>DependenceGraph&lt;ValueType&gt;</code>. This class
represents dependences between abstract objects of type <code>ValueType</code> - let's call
these objects 'nodes' for the sake of discussion. The dependences are
represented as a map from nodes to sets of nodes that depend on them.</p>

<p>It is worth noting that nodes are not stored in the Graph, but elsewhere, and
are referenced by using pointers to them. For example, if the node <code>Value</code> has
type <code>ValueType *</code> then internally for the <code>DependenceGraph</code> class the nodes
which depend on <code>Value</code> are stored in the set accessed as <code>Nodes[Value]</code>. The
type of this set is <code>std::set&lt;ValueType *&gt;</code>. In other words, the type of <code>Nodes</code>
is <code>std::map&lt;ValueType*, std::set&lt;ValueType *&gt;&gt;</code>.</p>

<p>There is a common sense interface exposed by <code>DependenceGraph&lt;ValueType&gt;</code>,
allowing users to add and remove nodes, add edges, check if a node depends on
another one, and clear the graph. There are also <code>nodes_begin</code> and <code>nodes_end</code>
iterators which allow the traversal of the nodes of the graph, and are nothing
but aliases for the <code>begin</code> and <code>end</code> iterators of the underlying <code>map</code>
structure. This allows the user to corrupt the <code>DependenceGraph</code> structure,
which we hope they won't do.</p>

<p>The type of the node iterators are <code>std::map&lt;ValueType *, std::set&lt;ValueType
*&gt;&gt;::iterator</code> (aliased to <code>nodes_iterator</code>), thus in order to traverse the
dependants of a single node, one needs to use <code>iterator-&gt;second.begin()</code> and
<code>iterator-&gt;second.end()</code>. The type of these iterators is <code>std::set&lt;ValueType
*&gt;::iterator</code> (aliased to <code>dependant_iterator</code>).</p>

<p>In order to test this class, compile and run <code>pass/test/TestDependence.cpp</code>.</p>

<h4>
<a id="ddgh-and-ddgcpp" class="anchor" href="#ddgh-and-ddgcpp" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DDG.h and DDG.cpp</h4>

<p>The simplest use of the <code>DependenceGraph</code> class is in the implementation of the
Data Dependence Graph (DDG) LLVM function pass, which builds the DDG of a
function using the def-use chains of instructions. The header file <code>DDG.h</code>
defines a trivial <code>FunctionPass</code> - <code>DataDependenceGraphPass</code>. The non-trivial
parts of the definition are that it is storing an instance of
<code>DependenceGraph&lt;Instruction&gt;</code> which can be accessed via a getter method and
cleared via <code>releaseMemory()</code>, and the declaration inside <code>getAnalysisUsage()</code>
that the pass doesn't modify the given <code>LLVM IR</code> in any way.</p>

<p>The implementation of the pass is in the source file <code>DDG.cpp</code>. It includes some
LLVM boilerplate (registering the pass), but the entry point is the
<code>runOnFunction</code> method. It first loops over the instructions of a function and
adds them to the internal (for the pass) <code>DependenceGraph</code> as nodes. Then it
goes over the instructions again and adds all of their 'users' from their
def-use chain as nodes dependant on the instructions in the <code>DependenceGraph</code>.</p>

<p>In order to test this pass, build the project and execute <code>tools/test-pass.sh</code>
with <code>-ddg</code> and a test <code>cpp</code> file as command line arguments.</p>

<p>This pass is useless on its own, as there is no way to extract its result. For
this reason, we need to look at <code>DDGPrinter.cpp</code>.</p>

<h4>
<a id="ddgprintercpp-and-graphtraits" class="anchor" href="#ddgprintercpp-and-graphtraits" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DDGPrinter.cpp and GraphTraits</h4>

<p>The DDG of a function can be printed using the <code>DDGPrinter</code> pass, defined in
<code>DDGPrinter.cpp</code>. It depends on the <code>DataDependenceGraphPass</code> as specified in
<code>getAnalysisUsage</code> and it uses the <code>DepGraphTraitsWrapper</code> class defined in
<code>DependenceTraits.h</code> in order to print the graph using the LLVM <code>GraphWriter</code>
class. Also, <code>InstDOTTraits.h</code> is included as it defines <code>DOTGraphTraits</code> for
<code>DependenceGraph&lt;Instruction&gt;</code>, which is used by <code>GraphWriter</code> to decide how to
label the nodes of the graph. This is specified in the <code>getNodeLabel</code> method of
<code>DOTGraphTraits</code> and it just prints the instruction as text.</p>

<p>It is worth discussing the structure of the classes defined in
<code>DependenceTraits.h</code>. In order to define LLVM's <code>GraphTraits</code> for a graph
structure, it needs to be represented by separate classes - one for the graph
and one for nodes in the graph. However, we decided to implement the graph as a
single class, as described in the <code>Dependence.h</code> section. For this reason, we
had to implement wrappers around it in order to comply with the requirements of
<code>GraphTraits</code>.</p>

<p>When specializing <code>GraphTraits</code> for a graph type, the following elements need to
be defined:</p>

<ul>
<li>
<code>NodeType</code> - the class that represents a node of the graph;</li>
<li>
<code>nodes_iterator</code> -
 an iterator that is constructed from a constant reference to a graph
     object and dereferences to a pointer to a node object;</li>
<li>
<code>nodes_begin</code> and <code>nodes_end</code> - methods that construct the begin and end
<code>nodes_iterator</code>s given a constant reference to a graph object;</li>
<li>
<code>ChildIteratorType</code> -
 an iterator that is constructed from a pointer to a node object and is
     dereferenced to a pointer to a node object;</li>
<li>
<code>child_begin</code> and <code>child_end</code> - methods that construct the begin and end
<code>ChildIteratorType</code>s given a pointer to a node object.</li>
</ul>

<p>This is done in the <code>GraphTraits&lt;DepGraphTraitsWrapper&lt;ValueType&gt;&gt;</code> class
defined in <code>DependenceTraits.h</code>.</p>

<p>The <code>DepGraphTraitsWrapper</code> class that <code>GraphTraits</code> is being specialized for,
needs to be constructed out of a <code>DependenceGraph</code> object. The constructor
allocates a <code>DepNodeTraitsWrapper</code> for every node in the given
<code>DependenceGraph</code> and stores a <code>std::map</code> from <code>ValueType *</code>s to these new
<code>DepNodeTraitsWrapper</code>s. Let's call the node type <code>Node</code> and the graph type
<code>Graph</code> for the sake of discussion. <code>Node</code> stores a reference to the <code>Graph</code>
that contains it, a constant <code>ValueType *</code> to the node it represents, and a
const pointer to <code>std::set&lt;ValueType *&gt;</code> - the set of the nodes that depend on
it. In this way, <code>Node</code> doesn't own any of the objects it references, but is
simply a proxy used to plug into the <code>GraphTraits</code> mechanism.</p>

<p>There are two more types defined in <code>DependenceTraits.h</code>: <code>DepNodeIterator</code> and
<code>DepNodeChildIterator</code>. These are the required <code>nodes_iterator</code> and
<code>ChildIteratorType</code> required by <code>GraphTraits</code>. The interesting functions in the
implementation are the constructors and the dereferencing operators
(<code>operator*</code>).</p>

<p><code>DepNodeIterator</code> is constructed from a <code>const_iterator</code> of the map
specialization used by <code>Graph</code>, which dereferences to a <code>std::pair&lt;ValueType *,
std::unique_ptr&lt;Node&gt;&gt;</code> and thus the <code>DepNodeIterator</code> is dereferenced by taking
the second element of that pair and extracting the pointer that it manages.
Explicitly, this looks like <code>idx-&gt;second.get()</code>, where <code>idx</code> is the previously
mentioned <code>const_iterator</code>.</p>

<p><code>DepNodeChildIterator</code> is constructed from an <code>iterator</code> of the set that is the
<code>value_type</code> of the map used in <code>DependenceGraph</code>, namely <code>std::set&lt;ValueType
*&gt;</code>. A reference to a <code>DepGraphTraitsWrapper</code> is also provided during
construction of the <code>DepNodeChildIterator</code>, as in order to dereference this
iterator to a <code>Node</code>, the <code>Graph</code> storing that <code>Node</code> needs to be known. This is
also the reason <code>Node</code>s store a reference to their containing <code>Graph</code> - in order
to pass it to the constructor of their child iterators. This iterator is
dereferenced by first dereferencing the stored set iterator and then using the
value to extract the <code>Node</code> that the <code>Graph</code> associates with this value. Namely,
<code>G[*idx]</code>, where <code>idx</code> is the previously mentioned <code>iterator</code> and <code>G</code> is an
instance of <code>Graph</code>.</p>

<p>All of this comes together when invoking <code>llvm::WriteGraph</code> in the method
<code>writeToFile</code> in the <code>Graph</code> class definition. By using the specialization of
<code>GraphTraits</code> <code>llvm::WriteGraph</code> knows how to traverse our custom graph and
write it to a file in the <code>.dot</code> format.</p>

<p>In order to test this pass, build the project and execute . The <code>DDGPrinter</code>
can be tested by running <code>tools/test-pass.sh</code> with <code>-dot-ddg</code> and a test <code>cpp</code>
file as command line arguments and inspecting the generated output. A <code>.dot</code>
file can be converted to a PDF using the <code>dot</code> tool:</p>

<pre><code>dot -Tpdf foo.dot -o foo.pdf
</code></pre>

<h4>
<a id="mdgh-and-mdgcpp" class="anchor" href="#mdgh-and-mdgcpp" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>MDG.h and MDG.cpp</h4>

<p>Once we have the pipeline set up for one dependence graph, it is easy to
replicate the code for others. The <code>MemoryDependenceGraphPass</code> that we
implement, is just a wrapper for LLVM's <code>MemoryDependenceAnalysis</code>. In <code>MDG.h</code>
we define the pass, which like the one in <code>DDG.h</code> stores a dependence graph on
instructions. In <code>getAnalysisUsage</code> we specify that the pass doesn't modify the
IR structure and that it depends on <code>MemoryDependenceAnalysis</code>. The dependence
graph can be accessed via the <code>getMDG</code> method and cleared via <code>releaseMemory</code>.</p>

<p>In <code>MDG.cpp</code> we traverse the function that the pass is being ran on, and we add
all of its instructions to the dependence graph. Then we consider only 'def'
dependencies from <code>MemoryDependenceAnalysis</code> and we add them to the graph also.
We should consider the other type of dependencies too, but since some of them
are not 'must'-dependencies, we ignore them for now.</p>

<p>The <code>MDGPrinter.cpp</code> implements a printing pass, almost identical to
<code>DDGPrinter.cpp</code>. In order to test the <code>MemoryDependenceGraph</code>, you can use
<code>tools/test-pass.sh</code>, similarly to the test for the <code>DataDependenceGraph</code>. The
first argument can be either <code>-mdg</code> or <code>-dot-mdg</code>. Where the former just tests
the memory dependence graph pass, without printing it.</p>

<h4>
<a id="cdgh-and-cdgcpp" class="anchor" href="#cdgh-and-cdgcpp" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CDG.h and CDG.cpp</h4>

<p>Similarly to <code>MDG.h</code> and <code>DDG.h</code>, <code>CDG.h</code> defines a simple pass that stores a
dependence graph and provides ways to access it and clear it. This dependence
graph, however, is on basic blocks, rather than instructions. The pass depends
on the <code>PostDominatorTree</code> analysis pass, since that is used to construct the
control dependence graph, as per Cytron '89.</p>

<p>The construction algorithm is implemented in <code>CDG.cpp</code> and the method
<code>runOnFunction</code> of the new pass. It starts with building a bottom-up traversal
stack of the post-dominator tree of the current function. It uses that to build
the post-dominator frontier for each of the nodes in the control-flow graph.
The reverse of that map (from basic blocks to their post-dominator frontier) is
the map from basic blocks to the ones that have a control dependence on these
basic blocks.</p>

<p>There is a standard printer class <code>CDGPriner</code> in the corresponding <code>.cpp</code> file.
<code>DOTGraphTraits</code> had to be specialized for <code>BasicBlocks</code> in order for this to
work. This specialization piggy-backs on the default function traits
implemented in LLVM, in order to pretty-print the list of instruction of the
basic block as labels in the resulting graph.</p>

<p>These passes can be tested using <code>tools/test-pass.sh</code> and <code>-cdg</code> or <code>-dot-cdg</code>
as first parameters.</p>

<h4>
<a id="pdgh-and-pdgcpp" class="anchor" href="#pdgh-and-pdgcpp" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>PDG.h and PDG.cpp</h4>

<p>The header file <code>PDG.h</code> defines yet another dependence graph on instructions.
However, this one combines all of the previous three - CDG, DDG, and MDG - into
a program dependence graph. A dependence on the other three passes is expressed
in <code>getAnalysisUsage</code>.</p>

<p>The construction of the program dependence graph is implemented in <code>PDG.cpp</code>. It
copies the dependences from the data and memory dependence graphs. The ones in
the control dependence graph, however, are on basic blocks rather than
instructions. In order to convert them, all the instructions of the dependant
basic block are made to depend on the last instruction of the parent basic
block. That instruction is always a conditional branch, in order for there to
be a control dependence. Additionally, extra dependences are added from the
branch instruction of basic blocks to phi nodes that have constants as
in-values from these basic blocks. This is done to reflect the fact that if a
phi node has a constant as an in-value that is equivalent to defining the
initial value for a variable in that in-block.</p>

<h4>
<a id="psgh" class="anchor" href="#psgh" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>PSG.h</h4>

<p>The program dependence graph is used by the <code>PDGSCCGraphPass</code> which constructs a
dependence graph of the strongly connected components in a <code>PDG</code>. This
information is stored as a <code>DependenceGraph</code> on <code>std::set</code>s of <code>const
Instruction *</code>s. Each set represents a set of <code>Instruction</code>s which constitute a
strongly connected component in the <code>PDG</code>.There is also a <code>std::map</code> from the root of
strongly connected components to the components themselves, which is used to act
as a memory storage for the sets. Pointers to this storage are used in the
output graph <code>PSG</code> and the map from instructions to their connected components
<code>InstToSCC</code>. In addition to the standard interface implemented for the other
dependence graphs, there is a getter that allows accessing the strongly
connected component of an instruction, given the instruction.</p>

<h4>
<a id="graphutilsh" class="anchor" href="#graphutilsh" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>GraphUtils.h</h4>

<p>A small library of graph utilities for <code>DependenceGraph</code>s. It exports functions
<code>transpose</code> and <code>findSCC</code> to respectively compute the transpose of a graph
(reversing the edges) and finding the strongly connected components of a graph,
using the Kosajaru's algorithm.</p>

<h4>
<a id="psgcpp" class="anchor" href="#psgcpp" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>PSG.cpp</h4>

<p>The implementation, which is in <code>PSG.cpp</code> works as follows. The <code>GraphUtils.h</code>
library is used to compute the root instruction of the SCC of each instruction
and is stored in the <code>component</code> map. This map is traversed and used to
construct the <code>SCCs</code> map from roots of strongly connected components to the
components themselves. After this is done, each SCC is added as a node to the
dependence graph <code>PSG</code> and the map from instructions to their components is
cached in <code>InstToSCC</code>. Finally, for each edge in the <code>PDG</code> a corresponding edge
is added in the <code>PSG</code>, where instructions are mapped to their SCCs.</p>

<h4>
<a id="decoupleloopsh-and-decoupleloopscpp" class="anchor" href="#decoupleloopsh-and-decoupleloopscpp" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DecoupleLoops.h and DecoupleLoops.cpp</h4>

<p>Finally, <code>DecoupleLoops.h</code> and <code>DecoupleLoops.cpp</code> implement a pass, that using
the <code>PSG</code> graph of a function marks all instructions of the function as either
<code>iter</code> or <code>work</code>. <code>iter</code> instructions make the loop go round, while <code>work</code>
instructions produce additional results from running the loop. All loops have
<code>iter</code> instructions, but if <code>work</code> instructions can be extracted, then the loop
can potentially benefit from Decoupled Software Pipelining. The result of this
pass is two <code>std::map</code>s from <code>const Loop *</code> to the set of <code>iter</code> SCCs and the
set of <code>work</code> SCCs. These are stored in the <code>PSG</code> pass, so it's memory shouldn't
be cleared in order for this pass to work. (maybe we should just copy the
memory).</p>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
