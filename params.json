{"name":"Icsa-dswp","tagline":"An implementation of Decoupled Software Pipelining","body":"An implementation of DSWP\r\n=========================\r\n\r\nCurrently, under development.\r\n\r\nGoals\r\n-----\r\n\r\nDecoupled Software Pipelining (DSWP) is an automatic thread extraction technique\r\n([Ottoni, 2005][ottoni2005]). There have been previous attempts at implementing\r\nit ([2011 project][2011-dswp-prj] and [2013 project][2013-dswp-prj]), but the\r\nefforts resulted in unfinished and unmaintainable solutions.\r\n\r\nTherefore, the goals of this project are to provide a complete, reusable and\r\nmaintainable implementation of the technique, which can then be integrated in\r\nprototypes of further research on the topic.\r\n\r\nUsage\r\n-----\r\n\r\n### Prerequisites\r\n\r\nThis project depends on LLVM+Clang 3.7.0 and is developed on Linux. Thus, no\r\nguarantees are made that it's going to work with any other version of LLVM or on\r\nany other operating system - sorry. Make sure you have the LLVM+Clang 3.7.0\r\nbinary directory on your system PATH in order to build and use the pass.\r\n\r\n### Building\r\n\r\nRun `tools/build.sh`. This script will use `cmake 2.8` and `make` in order to\r\nbuild the project.\r\n\r\nDevelopment\r\n-----------\r\n\r\n### Disclaimer\r\n\r\nThe following text would describe the repository when the implementation is\r\ncompleted - it may not describe its working state.\r\n\r\n### Available Passes\r\n\r\nThe `pass` directory contains the code for `libdswp.so` - a library that\r\ncontains the following LLVM 3.7.0 function passes:\r\n * `ddg` - builds the Data Dependence Graph of a function using the Use-Def\r\n   chains already built-in LLVM; in order for this pass to work, the bytecode\r\n   should be in SSA form;\r\n* `mdg` - builds the Memory Dependence Graph of a function using\r\n   `llvm / Analysis / MemoryDependenceAnalysis.h`;\r\nonly instruction definition dependencies are considered(no clobber /\r\n                                                        alias dependencies);\r\n* `cdg` - builds the[Control Dependence Graph][cytron1989] of a function;\r\n* `pdg` - combines the previous three graphs in a single graph of instruction\r\n              dependencies;\r\nnote that since `cdg` produces a basic block dependence graph all of the\r\n    instructions in the dependant block are made to depend on the branch\r\n        instruction of the dependency source;\r\n* `psg` - incomplete and memory leaking experimental pass;\r\nfinds the Strongly Connected Components of the Program Dependence\r\n    Graph and builds a graph out of them;\r\n * `dot-XXX` - prints a .dot representation of each function for the graph build\r\n   by `XXX` to a file;\r\n `XXX` is one of the five graph building passes;\r\n * `find-dswp` - uses the experimental `psg` pass to analyse an LLVM bytecode\r\n   file and prints DSWP opportunities to the standard output.\r\n\r\nIn order to analyze a `.cpp` file called `foo.cpp`, make sure you have LLVM\r\n3.7.0 installed and do the following:\r\n\r\n```\r\nclang++ foo.cpp -c -emit-llvm -o foo.bc\r\nopt -mem2dep foo.bc -o ssa.bc\r\nopt -load $ICSA_DSWP_HOME/build/pass/libdswp.so -find-dswp ssa.bc -o /dev/null\r\n```\r\n\r\nThe `test` directory contains example programs on which the DSWP pass can be\r\ntested and demonstrated.\r\n\r\n### Code Structure\r\n\r\nThis section talks about the source code of the project. It is meant to be read\r\nwhile looking at the source code, so go ahead and open an editor.\r\n\r\n#### Dependence.h\r\n\r\nThe starting point for understanding the code is the `Dependence.h` header file.\r\nIt implements the template class `DependenceGraph<ValueType>`. This class\r\nrepresents dependences between abstract objects of type `ValueType` - let's call\r\nthese objects 'nodes' for the sake of discussion. The dependences are\r\nrepresented as a map from nodes to sets of nodes that depend on them.\r\n\r\nIt is worth noting that nodes are not stored in the Graph, but elsewhere, and\r\nare referenced by using pointers to them. For example, if the node `Value` has\r\ntype `ValueType *` then internally for the `DependenceGraph` class the nodes\r\nwhich depend on `Value` are stored in the set accessed as `Nodes[Value]`. The\r\ntype of this set is `std::set<ValueType *>`. In other words, the type of `Nodes`\r\nis `std::map<ValueType*, std::set<ValueType *>>`.\r\n\r\nThere is a common sense interface exposed by `DependenceGraph<ValueType>`,\r\nallowing users to add and remove nodes, add edges, check if a node depends on\r\nanother one, and clear the graph. There are also `nodes_begin` and `nodes_end`\r\niterators which allow the traversal of the nodes of the graph, and are nothing\r\nbut aliases for the `begin` and `end` iterators of the underlying `map`\r\nstructure. This allows the user to corrupt the `DependenceGraph` structure,\r\nwhich we hope they won't do.\r\n\r\nThe type of the node iterators are `std::map<ValueType *, std::set<ValueType\r\n*>>::iterator` (aliased to `nodes_iterator`), thus in order to traverse the\r\ndependants of a single node, one needs to use `iterator->second.begin()` and\r\n`iterator->second.end()`. The type of these iterators is `std::set<ValueType\r\n*>::iterator` (aliased to `dependant_iterator`).\r\n\r\nIn order to test this class, compile and run `pass/test/TestDependence.cpp`.\r\n\r\n#### DDG.h and DDG.cpp\r\n\r\nThe simplest use of the `DependenceGraph` class is in the implementation of the\r\nData Dependence Graph (DDG) LLVM function pass, which builds the DDG of a\r\nfunction using the def-use chains of instructions. The header file `DDG.h`\r\ndefines a trivial `FunctionPass` - `DataDependenceGraphPass`. The non-trivial\r\nparts of the definition are that it is storing an instance of\r\n`DependenceGraph<Instruction>` which can be accessed via a getter method and\r\ncleared via `releaseMemory()`, and the declaration inside `getAnalysisUsage()`\r\nthat the pass doesn't modify the given `LLVM IR` in any way.\r\n\r\nThe implementation of the pass is in the source file `DDG.cpp`. It includes some\r\nLLVM boilerplate (registering the pass), but the entry point is the\r\n`runOnFunction` method. It first loops over the instructions of a function and\r\nadds them to the internal (for the pass) `DependenceGraph` as nodes. Then it\r\ngoes over the instructions again and adds all of their 'users' from their\r\ndef-use chain as nodes dependant on the instructions in the `DependenceGraph`.\r\n\r\nIn order to test this pass, build the project and execute `tools/test-pass.sh`\r\nwith `-ddg` and a test `cpp` file as command line arguments.\r\n\r\nThis pass is useless on its own, as there is no way to extract its result. For\r\nthis reason, we need to look at `DDGPrinter.cpp`.\r\n\r\n#### DDGPrinter.cpp and GraphTraits\r\n\r\nThe DDG of a function can be printed using the `DDGPrinter` pass, defined in\r\n`DDGPrinter.cpp`. It depends on the `DataDependenceGraphPass` as specified in\r\n`getAnalysisUsage` and it uses the `DepGraphTraitsWrapper` class defined in\r\n`DependenceTraits.h` in order to print the graph using the LLVM `GraphWriter`\r\nclass. Also, `InstDOTTraits.h` is included as it defines `DOTGraphTraits` for\r\n`DependenceGraph<Instruction>`, which is used by `GraphWriter` to decide how to\r\nlabel the nodes of the graph. This is specified in the `getNodeLabel` method of\r\n`DOTGraphTraits` and it just prints the instruction as text.\r\n\r\nIt is worth discussing the structure of the classes defined in\r\n`DependenceTraits.h`. In order to define LLVM's `GraphTraits` for a graph\r\nstructure, it needs to be represented by separate classes - one for the graph\r\nand one for nodes in the graph. However, we decided to implement the graph as a\r\nsingle class, as described in the `Dependence.h` section. For this reason, we\r\nhad to implement wrappers around it in order to comply with the requirements of\r\n`GraphTraits`.\r\n\r\nWhen specializing `GraphTraits` for a graph type, the following elements need to\r\nbe defined:\r\n\r\n * `NodeType` - the class that represents a node of the graph;\r\n * `nodes_iterator` -\r\n     an iterator that is constructed from a constant reference to a graph\r\n         object and dereferences to a pointer to a node object;\r\n * `nodes_begin` and `nodes_end` - methods that construct the begin and end\r\n   `nodes_iterator`s given a constant reference to a graph object;\r\n * `ChildIteratorType` -\r\n     an iterator that is constructed from a pointer to a node object and is\r\n         dereferenced to a pointer to a node object;\r\n * `child_begin` and `child_end` - methods that construct the begin and end\r\n   `ChildIteratorType`s given a pointer to a node object.\r\n\r\nThis is done in the `GraphTraits<DepGraphTraitsWrapper<ValueType>>` class\r\ndefined in `DependenceTraits.h`.\r\n\r\nThe `DepGraphTraitsWrapper` class that `GraphTraits` is being specialized for,\r\nneeds to be constructed out of a `DependenceGraph` object. The constructor\r\nallocates a `DepNodeTraitsWrapper` for every node in the given\r\n`DependenceGraph` and stores a `std::map` from `ValueType *`s to these new\r\n`DepNodeTraitsWrapper`s. Let's call the node type `Node` and the graph type\r\n`Graph` for the sake of discussion. `Node` stores a reference to the `Graph`\r\nthat contains it, a constant `ValueType *` to the node it represents, and a\r\nconst pointer to `std::set<ValueType *>` - the set of the nodes that depend on\r\nit. In this way, `Node` doesn't own any of the objects it references, but is\r\nsimply a proxy used to plug into the `GraphTraits` mechanism.\r\n\r\nThere are two more types defined in `DependenceTraits.h`: `DepNodeIterator` and\r\n`DepNodeChildIterator`. These are the required `nodes_iterator` and\r\n`ChildIteratorType` required by `GraphTraits`. The interesting functions in the\r\nimplementation are the constructors and the dereferencing operators\r\n(`operator*`).\r\n\r\n`DepNodeIterator` is constructed from a `const_iterator` of the map\r\nspecialization used by `Graph`, which dereferences to a `std::pair<ValueType *,\r\nstd::unique_ptr<Node>>` and thus the `DepNodeIterator` is dereferenced by taking\r\nthe second element of that pair and extracting the pointer that it manages.\r\nExplicitly, this looks like `idx->second.get()`, where `idx` is the previously\r\nmentioned `const_iterator`.\r\n\r\n`DepNodeChildIterator` is constructed from an `iterator` of the set that is the\r\n`value_type` of the map used in `DependenceGraph`, namely `std::set<ValueType\r\n*>`. A reference to a `DepGraphTraitsWrapper` is also provided during\r\nconstruction of the `DepNodeChildIterator`, as in order to dereference this\r\niterator to a `Node`, the `Graph` storing that `Node` needs to be known. This is\r\nalso the reason `Node`s store a reference to their containing `Graph` - in order\r\nto pass it to the constructor of their child iterators. This iterator is\r\ndereferenced by first dereferencing the stored set iterator and then using the\r\nvalue to extract the `Node` that the `Graph` associates with this value. Namely,\r\n`G[*idx]`, where `idx` is the previously mentioned `iterator` and `G` is an\r\ninstance of `Graph`.\r\n\r\nAll of this comes together when invoking `llvm::WriteGraph` in the method\r\n`writeToFile` in the `Graph` class definition. By using the specialization of\r\n`GraphTraits` `llvm::WriteGraph` knows how to traverse our custom graph and\r\nwrite it to a file in the `.dot` format.\r\n\r\nIn order to test this pass, build the project and execute . The `DDGPrinter`\r\ncan be tested by running `tools/test-pass.sh` with `-dot-ddg` and a test `cpp`\r\nfile as command line arguments and inspecting the generated output. A `.dot`\r\nfile can be converted to a PDF using the `dot` tool:\r\n\r\n```\r\ndot -Tpdf foo.dot -o foo.pdf\r\n```\r\n\r\n#### MDG.h and MDG.cpp\r\n\r\nOnce we have the pipeline set up for one dependence graph, it is easy to\r\nreplicate the code for others. The `MemoryDependenceGraphPass` that we\r\nimplement, is just a wrapper for LLVM's `MemoryDependenceAnalysis`. In `MDG.h`\r\nwe define the pass, which like the one in `DDG.h` stores a dependence graph on\r\ninstructions. In `getAnalysisUsage` we specify that the pass doesn't modify the\r\nIR structure and that it depends on `MemoryDependenceAnalysis`. The dependence\r\ngraph can be accessed via the `getMDG` method and cleared via `releaseMemory`.\r\n\r\nIn `MDG.cpp` we traverse the function that the pass is being ran on, and we add\r\nall of its instructions to the dependence graph. Then we consider only 'def'\r\ndependencies from `MemoryDependenceAnalysis` and we add them to the graph also.\r\nWe should consider the other type of dependencies too, but since some of them\r\nare not 'must'-dependencies, we ignore them for now.\r\n\r\nThe `MDGPrinter.cpp` implements a printing pass, almost identical to\r\n`DDGPrinter.cpp`. In order to test the `MemoryDependenceGraph`, you can use\r\n`tools/test-pass.sh`, similarly to the test for the `DataDependenceGraph`. The\r\nfirst argument can be either `-mdg` or `-dot-mdg`. Where the former just tests\r\nthe memory dependence graph pass, without printing it.\r\n\r\n#### CDG.h and CDG.cpp\r\n\r\nSimilarly to `MDG.h` and `DDG.h`, `CDG.h` defines a simple pass that stores a\r\ndependence graph and provides ways to access it and clear it. This dependence\r\ngraph, however, is on basic blocks, rather than instructions. The pass depends\r\non the `PostDominatorTree` analysis pass, since that is used to construct the\r\ncontrol dependence graph, as per [Cytron '89][cytron1989].\r\n\r\nThe construction algorithm is implemented in `CDG.cpp` and the method\r\n`runOnFunction` of the new pass. It starts with building a bottom-up traversal\r\nstack of the post-dominator tree of the current function. It uses that to build\r\nthe post-dominator frontier for each of the nodes in the control-flow graph.\r\nThe reverse of that map (from basic blocks to their post-dominator frontier) is\r\nthe map from basic blocks to the ones that have a control dependence on these\r\nbasic blocks.\r\n\r\nThere is a standard printer class `CDGPriner` in the corresponding `.cpp` file.\r\n`DOTGraphTraits` had to be specialized for `BasicBlocks` in order for this to\r\nwork. This specialization piggy-backs on the default function traits\r\nimplemented in LLVM, in order to pretty-print the list of instruction of the\r\nbasic block as labels in the resulting graph.\r\n\r\nThese passes can be tested using `tools/test-pass.sh` and `-cdg` or `-dot-cdg`\r\nas first parameters.\r\n\r\n#### PDG.h and PDG.cpp\r\n\r\nThe header file `PDG.h` defines yet another dependence graph on instructions.\r\nHowever, this one combines all of the previous three - CDG, DDG, and MDG - into\r\na program dependence graph. A dependence on the other three passes is expressed\r\nin `getAnalysisUsage`.\r\n\r\nThe construction of the program dependence graph is implemented in `PDG.cpp`. It\r\ncopies the dependences from the data and memory dependence graphs. The ones in\r\nthe control dependence graph, however, are on basic blocks rather than\r\ninstructions. In order to convert them, all the instructions of the dependant\r\nbasic block are made to depend on the last instruction of the parent basic\r\nblock. That instruction is always a conditional branch, in order for there to\r\nbe a control dependence. Additionally, extra dependences are added from the\r\nbranch instruction of basic blocks to phi nodes that have constants as\r\nin-values from these basic blocks. This is done to reflect the fact that if a\r\nphi node has a constant as an in-value that is equivalent to defining the\r\ninitial value for a variable in that in-block.\r\n\r\n#### PSG.h\r\n\r\nThe program dependence graph is used by the `PDGSCCGraphPass` which constructs a\r\ndependence graph of the strongly connected components in a `PDG`. This\r\ninformation is stored as a `DependenceGraph` on `std::set`s of `const\r\nInstruction *`s. Each set represents a set of `Instruction`s which constitute a\r\nstrongly connected component in the `PDG`.There is also a `std::map` from the root of\r\nstrongly connected components to the components themselves, which is used to act\r\nas a memory storage for the sets. Pointers to this storage are used in the\r\noutput graph `PSG` and the map from instructions to their connected components\r\n`InstToSCC`. In addition to the standard interface implemented for the other\r\ndependence graphs, there is a getter that allows accessing the strongly\r\nconnected component of an instruction, given the instruction.\r\n\r\n#### GraphUtils.h\r\n\r\nA small library of graph utilities for `DependenceGraph`s. It exports functions\r\n`transpose` and `findSCC` to respectively compute the transpose of a graph\r\n(reversing the edges) and finding the strongly connected components of a graph,\r\nusing the Kosajaru's algorithm.\r\n\r\n#### PSG.cpp\r\n\r\nThe implementation, which is in `PSG.cpp` works as follows. The `GraphUtils.h`\r\nlibrary is used to compute the root instruction of the SCC of each instruction\r\nand is stored in the `component` map. This map is traversed and used to\r\nconstruct the `SCCs` map from roots of strongly connected components to the\r\ncomponents themselves. After this is done, each SCC is added as a node to the\r\ndependence graph `PSG` and the map from instructions to their components is\r\ncached in `InstToSCC`. Finally, for each edge in the `PDG` a corresponding edge\r\nis added in the `PSG`, where instructions are mapped to their SCCs.\r\n\r\n#### DecoupleLoops.h and DecoupleLoops.cpp\r\n\r\nFinally, `DecoupleLoops.h` and `DecoupleLoops.cpp` implement a pass, that using\r\nthe `PSG` graph of a function marks all instructions of the function as either\r\n`iter` or `work`. `iter` instructions make the loop go round, while `work`\r\ninstructions produce additional results from running the loop. All loops have\r\n`iter` instructions, but if `work` instructions can be extracted, then the loop\r\ncan potentially benefit from Decoupled Software Pipelining. The result of this\r\npass is two `std::map`s from `const Loop *` to the set of `iter` SCCs and the\r\nset of `work` SCCs. These are stored in the `PSG` pass, so it's memory shouldn't\r\nbe cleared in order for this pass to work. (maybe we should just copy the\r\nmemory).\r\n\r\n[ottoni2005]: (http://dl.acm.org/citation.cfm?id=1100543)\r\n[2011-dswp-prj]: (http://www.cs.cmu.edu/~fuyaoz/courses/15745/)\r\n[2013-dswp-prj]: (http://www.cs.cmu.edu/~avelingk/compilers/)\r\n[cytron1989]: (http://dl.acm.org/citation.cfm?id=75280)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}